'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/clj-statecharts/docs/actions/','title':"Actions \u0026 Context",'section':"Docs",'content':"Actions \u0026amp; Context #  Actions #  Actions are side-effects that are executed on state transitions.\nThere are two kinds of actions:\n Actions that are executed when a transition happens Actions that are executed when transition in (entry) or transition out (exit) of a state  Transition Actions #  Instead of define a transition target as simply a keyword, you need to use the full form:\n{:on {:some-event {:target :some-state :actions some-action}}} The actions value can also be a vector, and the actions would be executed one by one.\n{:on {:some-event {:target :some-state :actions [action1 action2]}}} Entry/Exit Actions #  Entry actions are defined on a state, and are executed whenever this state is entered. Similar for exit actions - they are executed whenever leaving the state.\n{:states {:state1 {:entry some-action-on-entry :exit some-action-on-exit :on {...}}}} ;; entry/exit can also be vector of actions {:states {:state1 {:entry [action1 action2] :exit [action3 action4] :on {...}}}} Method Signature of the Action Functions #  The action function is invoked with two arguments: (state event)\n state is the current state event is the event that triggers the transition and execution of the action  Updating the State Context #  Actions can update the context of the state machine.\n(require \u0026#39;[statecharts.core :as fsm :refer [assign]]) (defn update-counter [state event] (update state :counter inc)) {:states {:state1 {:on {:some-event {:target :state2 :action (assign update-counter)}}}}} Note the action is wrapped with statecharts.core/assign. Without this it\u0026rsquo;s return value is ignored and the state context is not changed.\nThe event arg of update-counter would be {:type :some-event}. Extra keys could be passed when calling fsm/transition:\n(let [event {:type :some-event :k1 :v1 :k1 :v2}] (fsm/transition machine current-state event)) And the event argument passed to the update-counter would have these :k1 :k2 keys etc.\nA Full Example #  (ns statecharts-samples.trigger-actions (:require [statecharts.core :as fsm])) (defn fire-cameras [\u0026amp; _] (println \u0026#34;Firing the traffic cameras!\u0026#34;)) (def machine (fsm/machine {:id :lights :initial :red :states {:green {:on {:timer :yellow}} :yellow {:on {:timer {:target :red :actions fire-cameras}}} :red {:on {:timer :green}}} :on {:power-outage :red}})) (def service (fsm/service machine)) (fsm/start service) ;; :red =\u0026gt; :green (fsm/send service :timer) ;; :green =\u0026gt; yellow (fsm/send service :timer) ;; :yellow =\u0026gt; :red ;; fire-cameras would be called here (fsm/send service :timer) "});index.add({'id':1,'href':'/clj-statecharts/docs/concepts/','title':"Concepts: Machine, State, Service",'section':"Docs",'content':"Concepts: Machine, State, Service #  Machine \u0026amp; State #   A machine is a specification of transitions, states, etc. It is immutable. A state is, well, a state. It represents the state of some system at some specific moment. It\u0026rsquo;s also immutable.  How is the state different from the machine? The machine is like a map. A map could indicate how one could go from one place to another. Likewise, a machine indicates how a system could transition from one state to another.\n The state is like a place.  How is a machine like a map? The map itself is not in any place. It just contains all the directions. Similarly, the machine itself is not in any state. It just contains all the possible transitions.\nThe state itself (mainly) contains two piece of information:\n the current state value, e.g. :connecting, or [:connecting :state2]. (see Nested States for how to represent nested states). the current state.  The State Map #  The current state is expressed as a map like this:\n{:_state :waiting :user :jack :backoff 3000}  All keys that starts with an underscore (e.g. _state) is considered internal to clj-statecharts. Application code could read them, but should not modify them. All others keys are application-specific data, collectively called the \u0026ldquo;context\u0026rdquo; of the state machine.  State \u0026amp; Service #  How are machine/state connected to the higher level services?\nA service is stateful, and we need it for two reasons:\n We need a container of state to represent the state of system, which could transition over time. Actually it\u0026rsquo;s just an atom in the state record. For delayed transitions, we need someone to keep track of these scheduling information. In its essence a delayed transition is just a timer:  the timer is scheduled when entering the state if the machine transitions out of the state before the timer is fired, the timer shall be canceled.    "});index.add({'id':2,'href':'/clj-statecharts/docs/delayed/','title':"Delayed Transitions",'section':"Docs",'content':"Delayed Transitions #  Basic Delayed Transitions #  To specify a transition that shall happen automatically after some time, sue the :after keyword:\n{:states {:s1 {:after [{:delay 1000 :target :s2 :guard some-condition-fn :actions some-action} {:delay :2000 :target :s3 :actions some-action}]}}} All transition features like guards and actions could be used here, as you can see in the code snippet above.\nDynamic Delay #  The amount of delay could be expressed as a context function.\nFor example, in a state machine that manages a websocket connection, the reconnection delay could be calculated as an exponential backoff.\n(defn calculate-backoff \u0026#34;Exponential backoff, with a upper limit of 15 seconds.\u0026#34; [state \u0026amp; _] (-\u0026gt; (js/Math.pow 2 (:retries state)) (* 1000) (min 15000))) (defn update-retries [state \u0026amp; _] (update state :retries inc)) ;; Part of the machine definition {:states {:connecting {:entry try-connect :on {:success-connect :connected}} :disconnected {:entry (assign update-retries) :after [{:delay calculate-backoff :target :connecting}]} :connected {:on {:connection-closed :disconnected}}}} Notes #    Delayed transitions currently only works in the CLJS. CLJ support is going to be added soon.*\n  When using the Immutable API, the machine spec must have a :scheduler key that satisfies the statecharts.delayed.Scheduler protocol.\n  "});index.add({'id':3,'href':'/clj-statecharts/docs/xstate/','title':"Difference from XState",'section':"Docs",'content':"Difference from XState #  Why not use XState in CLJS? #   In XState the context can only be a plain js map. One can not use cljs objects (map/vector) as context, because xstate doesn\u0026rsquo;t preserve the context object\u0026rsquo;s prototype, because it uses Object.assign when updating the context. For a CLJS project, xstate may be good enough, but we still need a solution for CLJ projects. Last but not least, xstate uses strings to represent states everywhere, but in clj/cljs we tend to use keywords instead.  Unsupported XState Features #   parallel states invoking another machine/promise/actor  Different structure for the state map #  In xstate, the state object has two keys value and context\n{ value: \u0026#34;waiting\u0026#34;, context: { user: \u0026#34;jack\u0026#34;, backoff: 3000 } } But in clj-statecharts the state map is a flat map:\n{:_state :waiting :user \u0026#34;jack\u0026#34; :backoff 3000} In the state map, any underscored key (e.g. _state) is internal to clj-statecharts, which means your application code should not modify it (e.g. in an context function). The others are the application specific data (equivalent to the \u0026ldquo;context\u0026rdquo; of xstate).\nThe reason behind this is that after using the xstate-like two-level map structure in some real world projects, it\u0026rsquo;s obvious that the two-level map is hard to integrate into an existing project, e.g. putting the state inside a re-frame db.\n"});index.add({'id':5,'href':'/clj-statecharts/docs/get-started/','title':"Get Started",'section':"Docs",'content':"Get Started #  Installation #  Add the dep to to your project.clj/deps.edn/shadow-cljs.edn: \nThe below document assumes you have a require statement like this:\n(require \u0026#39;[statecharts.core :as fsm]) Two layers of APIs #  There are two layers of APIs in clj-statecharts:\n The Immutable API that deals with machines and states directly. This layer is purely functional. The Service API are the higher level one. It is built on top of the immutable API, stateful and easier to get started.  Part 1. The Immutable API #  Simply define a machine, which includes:\n the states and transitions on each state the initial state value the initial context  And use the fsm/initialize and fsm/transition functions.\n;; import proper ns (ns statecharts-samples.basic-immuatable (:require [statecharts.core :as fsm])) ;; define the machine (def machine (fsm/machine {:id :lights :initial :red :context nil :states {:green {:on {:timer {:target :yellow :actions (fn [\u0026amp; _] (println \u0026#34;transitioned to :yellow!\u0026#34;)) }}} :yellow {:on {:timer :red}} :red {:on {:timer :green}}} :on {:power-outage :red} })) (def s1 (fsm/initialize machine)) ; {:_state :red} (def s2 (fsm/transition machine s1 {:type :timer})) ; {:_state :green} (def s3 (fsm/transition machine s2 {:type :timer})) ; {:_state :yellow} (fsm/initialize machine) #  Returns the initial state of the machine. It also executes all the entry actions of the initial states, if any.\nIf you do not want these actions to be executed, use (fsm/initialize machine {:exec false}) instead. The action functions would be collected in the _actions key of the new state map. For example, the test code of clj-statecharts uses this feature to make assertions to ensure correct actions are collected during transitions.\n(fsm/transition machine state event) #  Returns the next state based the current state \u0026amp; event. It also executes all the entry/exit/transition actions.\nIf you do not want these actions to be executed, use (fsm/transition machine state event {:exec false}) instead.\nPart 2. The Service API #  The immutable API provides a clean interface so you can integrate it into your own state management system like re-frame.\nHowever, sometimes it\u0026rsquo;s more convenient to provide a higher level API that could manage the state out of the box. Here comes the service API.\nThe usage pattern for the service API is very simple:\n Define a machine Define a service that runs the machine Send events to trigger transitions on this machine. Use functions like fsm/state or fsm/value to get the state of the service.  ;; import proper ns (ns statecharts-samples.basic (:require [statecharts.core :as fsm])) ;; define the machine (def machine (fsm/machine {:id :lights :initial :red :context nil :states {:green {:on {:timer {:target :yellow :actions (fn [\u0026amp; _] (println \u0026#34;transitioned to :yellow!\u0026#34;)) }}} :yellow {:on {:timer :red}} :red {:on {:timer :green}}} :on {:power-outage :red} })) ;; define the service (def service (fsm/service machine)) ;; start the service (fsm/start service) ;; prints :red (println (fsm/value service)) ;; send events to trigger transitions  (fsm/send service :timer) ;; prints :green (println (fsm/value service)) (fsm/send service :timer) ;; prints :yellow (println (fsm/value service)) "});index.add({'id':6,'href':'/clj-statecharts/docs/guards/','title':"Guarded Transitions",'section':"Docs",'content':"Guarded Transitions #  Use Guarded Transitions #  Also called \u0026ldquo;conditional transitions\u0026rdquo;.\nWhen an event happens, the target state may depend on some condition.\nTo express this, add a :guard key in the transition map.\n The first transition that has is condition met is selected. If none is selected, the event is ignored.  (defn my-condition-fn [state event] ;; returns a boolean ) ;; Part of the machine definition {:states {:s1 {:on {:some-event [{:target :s2 :guard my-condition-fn :actions some-action} {:target :s3}]}}}} If my-condition-fn returns true, then the target is :s2. Otherwise the target would be :s3.\n"});index.add({'id':7,'href':'/clj-statecharts/docs/identifying-states/','title':"Identifying States",'section':"Docs",'content':"Identifying States #  Syntax of State Identifiers #  In describing a transition, we need a way to represent the target state.\nA state is uniquely identified by the vector of its path from the root, with the first element being a special keyword :\u0026gt;.\nFor instance, if we have a state :s1 and it has a child state :s1.1, then they could be identified by [:\u0026gt; :s1] and [:\u0026gt; :s1 :s1.1] respectively.\nThere are other ways to represent a state in transition:\n If the first element of the vector of keywords is not :\u0026gt;, it represents a relative path. A keyword :foo is short for [:foo] If the first element of the vector of keywords is special keyword :., it represents a child state of the current state. A nil target represents a internal self-transition  Some examples:\n{:states {:s1 {:on {:event1_2 :s2 ;; (1) :event_1_1.1 [:. :s1.1]} ;; (2) :states {:s1.1 {:on {:event1.1_1.2 :s1.2 :event1.1_2 [:\u0026gt; :s2] ;; (3) }}}} :s2 {:on {:event_2_2 {:actions some-action}}}}} ;; (4) (1) We want to represent state :s2 in the context of :s1, so we can simply write :s2.\n(2) We want to represent state [:s1 :s1.1] in the context of :s1, which means we can use either the relative syntax [:. :s1.1] or the absolute syntax [:\u0026gt; :s1 :s1.1]\n(3) We want to represent the state :s2 in the context of :s1.1, which means we had to use the absolute syntax here.\n(4) When the target is not given (or nil), it means an internal self-transition.\n"});index.add({'id':8,'href':'/clj-statecharts/docs/nested-states/','title':"Nested States",'section':"Docs",'content':"Nested States #  About Nested States (a.k.a Compound States) #  One of the greatest power of statecharts is that it could prevent the \u0026ldquo;states explosion\u0026rdquo; problem of a tradition finite state machine. The power comes from the concept of \u0026ldquo;compound states\u0026rdquo; in statecharts:\n A state can define its sub-states, a.k.a child states If a state doesn\u0026rsquo;t handle an event, its parent would handle it (if it can).  In this sense a statecharts is a tree, and the event is handled by searching from the current node up to the root, until whichever node is found to have specified a handler for this event.\nHere is a more in-depth concept explanation in the StateCharts 101.\nFor example a state machine for a calculator could have a \u0026ldquo;clear screen\u0026rdquo; event that is only handled by the root node.\n{:id :calculator :on {:clear-screen {:target :operand1 :actions (assign reset-inputs)}} {:states {:operand1 {:on {:input-digit :operand1 :input-operator :operator}} :operator {:on {:input-operator :operand2}} :operand2 {:on {:input-digit :operand2 :equals :result}}}}} In a traditional finite state machine, all states would have to handle this event by themselves.\n"});index.add({'id':9,'href':'/clj-statecharts/docs/integration/re-frame/','title':"Re-frame Integration",'section':"Docs",'content':"Re-frame Integration #  First, re-frame itself is much like a simple state machine: an event triggers the change of the app-db (much like the context in statecharts), as well as execution of other effects (much like actions in a fsm/statecharts).\nThere are two ways to integrate clj-statecharts with re-frame:\n Integrate re-frame with the immutable api Or integrate with the service api  The statecharts.re-frame namespace provides some goodies for both ways of integration.\nIntegrate re-frame with the Immutable API #  It\u0026rsquo;s pretty straight forward to integrate the immutable API of statecharts into re-frame\u0026rsquo;s event handlers:\n(ns mymodule (:require [re-frame.core :as rf] [statecharts.core :as fsm] [statecharts.integrations.re-frame :as fsm.rf])) (def mymodule-path [(rf/path :mymodule)]) (def my-machine (-\u0026gt; (fsm/machine {:id :mymodule :initial :init :states {...} :integrations {:re-frame {:path mymodule-path ;; (1) :initialize-event :mymodule/init :transition-event :mymodule/fsm-transition}}}) (fsm.rf/integrate) ;; (2) )) The tricky part is to how to use the event system of re-frame to transition the state machine. This is done by fsm.rf/integrate.\nThe call to fsm.rf/integrate would do the following for you:\n register an re-frame event handler for :mymodule/init that calls fsm/initialize and store the resulting state in the given path (i.e. mymodule-path in the this example) register an re-frame event handler :mymodule/fsm-transition, that when triggered, simply calls fsm/transition with the event args.  Here is an example of loading the list of friends of current user:\n(ns statecharts-samples.rf-integration (:require [re-frame.core :as rf] [statecharts.core :as fsm :refer [assign]] [statecharts.integrations.re-frame :as fsm.rf])) (def friends-path [(rf/path :friends)]) (def load-friends (fsm.rf/call-fx {:http-xhrio {:uri \u0026#34;/api/get-friends.json\u0026#34; :method :get :on-failure [:friends/fsm-event :fail-load] :on-success [:friends/fsm-event :success-load]}})) (defn on-friends-loaded [state {:keys [data]}] (assoc state :friends (:friends data))) (defn on-friends-load-failed [state {:keys [data]}] (assoc state :error (:status data))) (def friends-machine (fsm/machine {:id :friends :initial :loading :integrations {:re-frame {:path friends-path :initialize-event :friends/init :transition-event :friends/fsm-event}} :states {:loading {:entry load-friends :on {:success-load {:actions (assign on-friends-loaded) :target :loaded} :fail-load {:actions (assign on-friends-load-failed) :target :load-failed}}} :loaded {} :load-failed {}}})) Notice the use of statecharts.integrations.re-frame/call-fx to dispatch an effect in a fsm action.\nDiscard stale events with epoch support #  Under the [:integrations :re-frame] key, you can specify an epoch? boolean flag. To see why you may need it, first let\u0026rsquo;s see a real world problem.\nImagine there is a image viewing application which users could click one image from a list of thumbnails, and the application would download and show the original high-quality image. Also imagine the download/show is managed by a state machine, so there are states like loading, loaded, load-failed, and events like :load-image, :success-load, :fail-load etc. For instance, upon successful download the image with an ajax request, the :success-load event would be fired, and the machine would enter :loaded state. The UI would then display the image.\nOne problem arises when the user clicks too quickly, for instance, after clicking on image A, and quickly on image B. It\u0026rsquo;s possible that upon successful downloading of image A, the :success-load fires and the UI displays the image A, but the user wants to see image B. (Eventually image B would be displayed, but this \u0026ldquo;flaky\u0026rdquo; experience may annoy users.)\nOne way is to always cancel the current ajax request when requesting for a new one. But sometimes it maybe not feasible to do so. So clj-statecharts provides an epoch? flag in this re-frame integration for such uses cases.\n(-\u0026gt; (fsm/machine {:id :image-viewer :states {...} :integrations {:re-frame {:transition-event :viewer/fsm-event :epoch? true ;; (1) ...}}}) (fsm.rf/integrate)) This epoch? flag would add some extra features to the state:\n Upon the initialize event, the state map would have an _epoch key populated by default, whose value is an integer. Later if you re-initialize the machine, the _epoch key would be automatically incremented by 1. When you dispatch an event to the fsm, typically in a callback function of some async operations like sending an ajax request, you can dispatch a keyword, or a map with an :type key (actually :event-foo is short for {:type :event-foo}. In this map you can pass an :epoch key, which could serve the purpose to automatically discard this event in the :_epoch of the state machine changes.  (ajax/send {:url \u0026#34;http://image.com/imageA\u0026#34; ;; this event is always accepted :callback #(rf/dispatch [:viewer/fsm-event :success-load %])}) (ajax/send {:url \u0026#34;http://image.com/imageA\u0026#34; ;; For this event, when the callback is called, if the provided ;; epoch is not the same as the state\u0026#39;s current _epoch value, the ;; event would be ignored. :callback #(rf/dispatch [:viewer/fsm-event {:type :success-load :epoch 1} %])}) Integrate with the Service API #  When integrating re-frame with the service api of clj-statecharts, the state is stored in the service, and is synced to re-frame app-db by calling to statecharts.integrations.re-frame/connect-rf-db.\n(ns statecharts-samples.rf-integration-service (:require [statecharts.core :as fsm :refer [assign]] [re-frame.core :as rf] [statecharts.integrations.re-frame :as fsm.rf])) (def friends-path [(rf/path :friends)]) (declare friends-service) (rf/reg-event-fx :friends/init (fn [] (fsm/start friends-service) ;; (1) nil)) (defn load-friends [] (send-http-request {:uri \u0026#34;/api/get-friends.json\u0026#34; :method :get :on-success #(fsm/send friends-service {:type :success-load :data %}) :on-failure #(fsm/send friends-service {:type :fail-load :data %})})) (defn on-friends-loaded [state {:keys [data]}] (assoc state :friends (:friends data))) (defn on-friends-load-failed [state {:keys [data]}] (assoc state :error (:status data))) (def friends-machine (fsm/machine {:id :friends :initial :loading :states {:loading {:entry load-friends :on {:success-load {:actions (assign on-friends-loaded) :target :loaded} :fail-load {:actions (assign on-friends-load-failed) :target :load-failed}}} :loaded {} :load-failed {}}})) (defonce friends-service (fsm/service friends-machine)) (fsm.rf/connect-rf-db friends-service [:friends]) ;; (2) (defn ^:dev/after-load after-reload [] (fsm/reload friends-service friends-machine)) ;; (3) (1) call fsm/start on the service in some event handler\n(2) sync the state machine context to some sub key of re-frame app-db with statecharts.integrations.re-frame/connect-rf-db\n(3) Make sure the service keeps a reference to the latest machine definition after hot-reloading.\nBe aware that state is updated into the app-db path in a \u0026ldquo;unidirectional\u0026rdquo; sense. If you update the app-db data (for instance modify the :friends key in the above example), it would not affect the state machine and would be overwritten by the next state machine update.\nImmutable or Service? #  Integrate with the immutable API when:\n The state machine states changes are mostly driven by UI/re-frame events (e.g. button clicks) You need to modify the state directly in other re-frame events  Integrate with the service API when:\n The state changes are mostly driven by non UI/re-frame events (e.g. websocket states management)  Further Reading #   Re-frame EP 003 - Finite State Machines  "});index.add({'id':10,'href':'/clj-statecharts/docs/transitions/','title':"Transitions",'section':"Docs",'content':"Transitions #  Transitions are the most important parts of a state machine, since it embodies the major logic of the application.\nBasic Transitions #  The basic elements of a transition is the target state and the actions to execute.\n{:states {:s1 {:on {:event1 {:target :s2 :actions some-action-fn}}}} If the current state is :s1 and event :event1 happens, the new state would be :s2 and the action function some-action-fn would be executed.\nSome syntax sugars:\n{:states {:s1 {:on {:event1 {:target :s2 :actions [action-fn1 action-fn2]} ;; (1) :event2 :s3}}}} ;; (2) (1) The actions could be a vector of multiple action functions to execute\n(2) If there is no actions, the transition could be simplified to be a single\nPlease note that event names could be any keywords, with one exception: keywords namespace \u0026ldquo;fsm\u0026rdquo; is considered reserved for clj-statecharts\u0026rsquo;s internal use, so do not use event names like :fsm/foo in your application code.\nInternal \u0026amp; External Transitions #  Before reading this section, make sure you have read the Identifying States about the absolute and relative syntax of representing a state.\nA state could transition to one of its child states.\n If the transition triggers the entry/exit actions on the parent state, it\u0026rsquo;s called an external transition. Otherwise, it\u0026rsquo;s called an internal transition.  Here is an example of an internal \u0026amp; external transition:\n{:states {:s1 {:initial :s1.1 :entry entry1 :exit exit1 :on {:event1_1.2_internal [:. :s1.2] ;; (1) :event1_1.2_external [:\u0026gt; :s1 :s1.2]} ;; (2) :states {:s1.1 {} :s1.2 {}}}}} State :s1 has two child states :s1.1 and :s1.2.\n(1) When event event1_1.2_internal happens, the new state would be :s1.2, but the entry/exit actions of state :s1 would not be executed.\n(2) When event event1_1.2_external happens, the new state would also be :s1.2, but the entry/exit actions of state :s1 would be executed.\nSelf Transitions #  A state could transition to itself, this is called a self-transition.\nFor instance, a calculator FSM could have a state :operand1 representing the state that the user is typing the first operand. So the :input-digit event should keep the state machine in that state (but using actions to update the value of the operand on each input), instead of transitioning to a new state.\nA self-transition could also be either internal or external. To specify an internal self-transition, simply omit the :target key in the transition map.\nFor instance:\n{:states {:s1 {:entry entry1 :exit exit1 :on {:event1_1_internal {:actions some-action} ;; (1) :event1_1_external :s1 ;; (2) }}}} (1) For event :event1_1_internal, the target state is not specified (or nil). In this case, the entry/exit actions of :s1 would not be executed.\n(2) For event :event1_1_external, the target state is explicitly provided as itself, so the entry/exit actions of :s1 would be executed.\nEventLess Transitions #  Quoting XState doc:\nAn eventless transition is a transition that is always taken when the machine is in the state where it is defined, and when its guards evaluates to true. They are always checked when the state is first entered, before handling any other events. Eventless transitions are defined on the :always key of the state node:\nGiven the next state machine:\n{:states {:s1 {:entry entry1 :exit exit1 :on {:e12 :s2 :actions action12}} :s2 {:entry entry2 :exit exit2 :always [{:guard guard23 :target :s3 :actions action23} {:guard guard24 :target :s4 :actions action23}] :on {:e23 :s3}} :s3 {:entry entry3} :s4 {}}} Assume current state is :s1, and event :e12 happens.\n The target state is :s2. Because :s2 has eventless transitions defined, it would immediately evaluates the guard function guard23. If guard23 returns a truthy value, the machine would transition to state :s3. In this case these actions would be executed one by one:  exit1 action12 entry2 exit2 action23 entry3   Otherwise guard24 would be evaluated. If guard24 returns truthy, the machine would transition to :s4 (and similarly a list of actions would be executed). Otherwise it would stay in :s2.  The event args that accompanies :e12 would be passed to every action that is executed.\n"});})();